<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>reveal-md</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/base16/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="\r?\n---\r?\n" data-separator-vertical="\r?\n----\r?\n">
          <textarea data-template>
            <style>
  .reveal {
    font-family: "Open Sans", "Helvetica Neue", Arial, sans-serif;
    line-height: 1.4;
    font-size: 24px;
  }

  .reveal .slides {
    width: 1300px !important;
  }

  .reveal h1, .reveal h2, .reveal h3 {
    letter-spacing: 0.5px;
  }

  li:not(:last-child) {
   margin-bottom: 8px;
  }
</style>

# Nix

---

## Another package manager??

<ul>
  <li class="fragment">
    Functional builds: Packages are treated as functions without side-effect > build output is determined solely by its inputs.
  </li>

  <li class="fragment">
  Multiple versions side-by-side: Different versions or variants of a package get unique hashed paths. This avoids conflicts ("DLL hell") - you can have e.g. two versions of a library or compiler installed concurrently without interference.
  </li>

  <li class="fragment">
    Atomic upgrades & rollbacks: Upgrades simply add new versions under new paths, so they're atomic and leave the old version intact. If an update breaks something, you can roll back into a previous generation.
  </li>

  <li class="fragment">
    Declarative, shareable environments: Nix lets you declare exactly the list of tools and libraries you want, and reproduce that setup anywhere. You check your Nix expressions into version control, and any colleague (or CI system) can rebuild the same environment from that code.
  </li>

  <li class="fragment">
    Figure: NixOS boot menu showing multiple system generations. Nix makes upgrades atomic by never overwriting existing files, so old and new system states coexist. If an update fails, selecting an older generation at boot rolls back to a known-good configuration.
  </li>
<ul>

---

## The Nix Trinity

<div style="display: flex; align-items: center;">
  <img src="img/trinity.avif" width="500" style="margin-right: 20px;">
  <ul>
    <li class="fragment">
      Nix Language (DSL): Functional language for build recipes. Every package or configuration is described as a Nix expression (also called derivation), ensuring deterministic, reproducible builds. A single language used for packages, shells, and even OS configs.
    </li>
    <li class="fragment">
      Nixpkgs: Repository of Nix expressions for thousands of tools (over 120,000 packages). It includes multiple compilers (GCC, Clang, etc.), libraries, and utilities. Nixpkgs is updated continuously, and you can pin it (via flakes) to a commit for reproducibility.
    </li>
    <li class="fragment">
      NixOS: Linux distribution built on Nix. Entire OS (kernel, services, config files) is specified in Nix. Atomically upgrade (and rollback) the whole system. System is reproducible - copy NixOS config to another machine to get an identical setup.
    </li>
  </ul>
</div>

---

## Home Manager & Dev Experience
<ul>
  <li class="fragment">
    Declarative user environments: Home Manager lets you manage your home directory (dotfiles, programs, shell, editor settings, etc.) as Nix code. Replace ad-hoc scripts and manual installs with a single Nix config. Changes to your dev tools or dotfiles become simple edits in one place.
  </li>

  <li class="fragment">
    Reproducibility across machines: Use Home Manager to implement a dotfiles repo. On a new machine you just install Nix, run Home Manager, and you have your exact environment (packages, Shell/Vim/IDE settings, etc.).
  </li>

  <li class="fragment">
    Flexibility: Runs on Linux and macOS - Your colleagues can use it on their preferred platform. (Even on shared servers, each user can have their own Home Manager profile without needing root.)
  </li>
</ul>

Demo: Nix Flake with Clang

Below is a minimal flake.nix that pulls Clang from Nixpkgs and builds a simple C program (hello.c). It illustrates how easily Nix can set up a consistent environment and build:

{
 description = "Hello with Clang";
 inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
 outputs = { self, nixpkgs }:
  let pkgs = import nixpkgs { system = "x86_64-linux"; }; in {
    packages.x86_64-linux.hello = pkgs.stdenv.mkDerivation {
        name = "hello-clang";
        src = ./hello.c;
        buildInputs = [ pkgs.clang ];
        unpackPhase = "true";  # skip default unpack (src is a single file)
        buildPhase = "clang -o hello hello.c";
        installPhase = ''
          mkdir -p $out/bin
          cp hello $out/bin/
        '';
      };
    };
}

Run nix build .#hello to compile.  (This creates result/bin/hello - the built program.)

You get a shell with Clang by nix develop on this flake (since buildInputs includes pkgs.clang).

Clang is coming from Nixpkgs, so you're using an exactly defined compiler version.  Anyone else building this flake gets the same Clang (and libraries) without further config.

Call to Action: Try Nix!

Install Nix (on Linux or macOS) and experiment.  It's cross-platform, so you can use it on your laptop or dev machine alongside existing tools.

Browse Nixpkgs: over 120k packages are available (including many C toolchains, libraries, and tools).  For most libraries or compilers you need, there's already a Nix expression ready to use.

Use flakes and Home Manager: take control of your dev environment in code.  For example, specify exactly which GCC/Clang version and flags your C project needs.  Version-control these specs so builds are reproducible.

Tell IT about Nix: it's multi-user safe (no one can overwrite the core system; each user has isolated profiles).  Nix installs side-by-side with system packages and allows atomic upgrades/rollbacks, so the risk is low.  With Nix on our dev servers, we can ensure everyone has the right toolchain without fighting "it works on my machine" bugs.

Get started resources: NixOS website (nixos.org) has guides and links.  Maybe start a small project or container using Nix.  See how smooth rebuilding your environment can be.  Once you're convinced, we can push for Nix to be officially supported on our servers - then everyone benefits from reproducible C builds and up-to-date tools.

          </textarea>
        </section>
      </div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./mermaid/dist/mermaid.min.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"_":["slides.md"],"static":"_site"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
